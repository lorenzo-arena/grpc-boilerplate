/**
 * @file StreamRequestManager.cc
 *
 * @brief This class provides the implementation for the StreamRequestManager class.
 *
 * @author Lorenzo Arena
 *
 */

#include "StreamRequestManager.h"

#include <grpcpp/grpcpp.h>
#include <chrono>

#include "Logger.h"
#include "AsyncServer.h"

/**
 * Calls the super constructor by also setting AsyncNotifyWhenDone
 */
StreamRequestManager::StreamRequestManager(AsyncServer *server)
    : AsyncRPCManager(server->CompletionQueue(), true), server_(server), writer_(&ctx_), counter_(0), finishCounter_(0)
{
    Logger::Debug("StreamRequestManager: allocating");

    /* Fire the state machine */
    Proceed(true);
}

StreamRequestManager::~StreamRequestManager()
{
    Logger::Debug("Destroying stream request manager -> ", this);
}

void StreamRequestManager::createHandler(__attribute__((unused)) bool ok)
{
    /* Make this instance progress to the POSTCREATE state as soon as a request is received */
    status_ = POSTCREATE;

    Logger::Debug("StreamRequestManager: starting wait for request..");

    server_->AsyncService()->RequestStreamRequest(&ctx_, &request_, &writer_, cq_, cq_, this);
}

void StreamRequestManager::postCreateHandler(__attribute__((unused)) bool ok)
{
    Logger::Debug("StreamRequestManager: creating new request..");
    auto streamRequestManager = std::make_unique<StreamRequestManager>(server_);
    server_->AddManager(std::move(streamRequestManager));

    /* TODO : add cancellation if wrong response sent */

    /* Move in the state machine */
    status_ = PROCESS;
    Proceed(true);
}

void StreamRequestManager::processHandler(__attribute__((unused)) bool ok)
{
    if (ctx_.IsCancelled())
    {
        status_ = CANCELLED;

        /* Do not spawn any event; one is generated by the set of AsyncNotifyWhenDone */
    }
    else
    {
        /* Write up to 10 times */
        if (counter_ < 10)
        {
            status_ = WAITING;

            /* Create stream response */
            response_.set_text("Response " + std::to_string(counter_));
            Logger::Debug("StreamRequestManager: writing -> ", response_.text());
            writer_.Write(response_, this);
        }
        else
        {
            status_ = FINISH;

            Logger::Debug("StreamRequestManager: finishing request..");
            writer_.Finish(grpc::Status::OK, this);
        }
    }
}

void StreamRequestManager::waitingHandler(__attribute__((unused)) bool ok)
{
    if (ctx_.IsCancelled())
    {
        status_ = CANCELLED;

        /* Do not spawn any event; one is generated by the set of AsyncNotifyWhenDone */
    }
    else
    {
        status_ = PROCESS;

        counter_++;

        /* Simulate an event with an alarm, so that the stream goes back to writing */
        auto deadline = std::chrono::system_clock::now() + std::chrono::milliseconds(300);
        wakeAlarm_.Set(cq_, deadline, this);
    }
}

void StreamRequestManager::cancelledHandler(__attribute__((unused)) bool ok)
{
    Logger::Debug("StreamRequestManager: cancelled");
    finished_ = true;
}

void StreamRequestManager::finishHandler(__attribute__((unused)) bool ok)
{
    /* Since the AsyncNotifyWhenDone flag was set, this state will be entered
     * two times */
    if (finishCounter_ == 0)
    {
        Logger::Debug("StreamRequestManager: finished, waiting for the event set by AsyncNotifyWhenDone..");
        finishCounter_++;
    }
    else
    {
        Logger::Debug("StreamRequestManager: finished");
        finished_ = true;
    }
}
